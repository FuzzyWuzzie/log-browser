{
"version":3,
"file":"app.js",
"sourceRoot":"file:///",
"sources":["C:/Users/Kenton/Projects/log-browser/src/Ajax.hx","C:/Users/Kenton/Projects/log-browser/src/App.hx","C:/HaxeToolkit/haxe/lib/react/0,2,0/src/lib/api/react/ReactMacro.hx","C:/HaxeToolkit/haxe/std/haxe/macro/MacroStringTools.hx","C:/HaxeToolkit/haxe/std/js/_std/HxOverrides.hx","C:/HaxeToolkit/haxe/std/List.hx","C:/HaxeToolkit/haxe/std/js/_std/Reflect.hx","C:/HaxeToolkit/haxe/std/js/Boot.hx","C:/HaxeToolkit/haxe/lib/msignal/1,2,2/msignal/Signal.hx","C:/HaxeToolkit/haxe/lib/msignal/1,2,2/msignal/Slot.hx","C:/HaxeToolkit/haxe/lib/msignal/1,2,2/msignal/SlotList.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/base/AsyncBase.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/Deferred.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/Promise.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/Stream.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/PublicStream.hx","C:/HaxeToolkit/haxe/lib/promhx/1,0,21/src/main/promhx/base/EventLoop.hx","C:/Users/Kenton/Projects/log-browser/src/stores/ListStore.hx","C:/Users/Kenton/Projects/log-browser/src/stores/LogStore.hx","C:/Users/Kenton/Projects/log-browser/src/views/LogFiles.hx","C:/Users/Kenton/Projects/log-browser/src/views/LogInspector.hx","C:/HaxeToolkit/haxe/std/js/_std/Std.hx"],
"sourcesContent":["import js.html.XMLHttpRequest;\r\nimport promhx.Promise;\r\nimport promhx.Deferred;\r\n\r\n@:enum\r\nabstract HTTPMethod(String) from String to String {\r\n\tvar GET = \"GET\";\r\n\tvar POST = \"POST\";\r\n\tvar PUT = \"PUT\";\r\n\tvar DELETE = \"DELETE\";\r\n}\r\n\r\ntypedef Response = {\r\n\tvar status:Int;\r\n\tvar response:Dynamic;\r\n\tvar xhr:XMLHttpRequest;\r\n};\r\n\r\nclass Ajax {\r\n\tprivate static function res(xhr:XMLHttpRequest):Response {\r\n\t\treturn {\r\n\t\t\tstatus: xhr.status,\r\n\t\t\tresponse: xhr.response,\r\n\t\t\txhr: xhr\r\n\t\t};\r\n\t}\r\n\r\n\tpublic static function request(method:HTTPMethod, url:String, ?data:Dynamic):Promise<Response> {\r\n\t\tvar def = new Deferred<Response>();\r\n\t\tvar prom = def.promise();\r\n\r\n\t\tvar xhr:XMLHttpRequest = new XMLHttpRequest();\r\n\t\txhr.open(method, url, true);\r\n\t\txhr.onload = function() {\r\n\t\t\tif(xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\t\tdef.resolve(res(xhr));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdef.throwError(res(xhr));\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar error = function() {\r\n\t\t\tdef.throwError(res(xhr));\r\n\t\t};\r\n\t\txhr.onerror = error;\r\n\t\txhr.onabort = error;\r\n\t\txhr.ontimeout = error;\r\n\t\tif(data != null) {\r\n\t\t\txhr.send(data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\txhr.send();\r\n\t\t}\r\n\r\n\t\treturn prom;\r\n\t}\r\n}","import api.react.ReactDOM;\r\nimport api.react.ReactMacro.jsx;\r\nimport js.Browser;\r\nimport socketio.Client;\r\nimport socketio.Socket;\r\n\r\nimport views.LogFiles;\r\nimport views.LogInspector;\r\n\r\nclass App {\r\n\tpublic static var console:js.html.Console = Browser.console;\r\n\r\n\tstatic public function main() {\r\n\t\tvar socket:Socket = Client.connect();\r\n\t\tReactDOM.render(jsx('<$LogFiles />'), Browser.document.getElementById('logFiles'));\r\n\t\tReactDOM.render(jsx('<$LogInspector />'), Browser.document.getElementsByTagName('main')[0]);\r\n\t\tstores.ListStore.update();\r\n\t\tstores.LogStore.update('');\r\n\t}\r\n}","package api.react;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\n\n/**\n\tProvides a simple macro for parsing jsx into Haxe expressions.\n**/\nclass ReactMacro\n{\n\t#if macro\n\tstatic var reInterpolationClass = ~/(<|<\\/)\\$/g;\n\tstatic var reInterpolationVar = ~/\\$([a-z_][a-z0-9_]*)/gi;\n\tstatic var reInterpolationExpr = ~/\\${/g;\n\tstatic var reAttributeBinding = ~/=({[^}]+})/g;\n\t\n\tpublic static macro function jsx(expr:ExprOf<String>):Expr\n\t{\n\t\t#if display\n\t\treturn macro api.react.React.createElement(${expr});\n\t\t#else\n\t\treturn parseJsx(ExprTools.getValue(expr), expr.pos);\n\t\t#end\n\t}\n\n\tstatic function parseJsx(jsx:String, pos:Position):Expr\n\t{\n\t\tjsx = escapeJsx(jsx);\n\t\ttry \n\t\t{\n\t\t\tvar xml = Xml.parse(jsx);\n\t\t\tvar expr = parseJsxNode(xml.firstElement(), pos);\n\t\t\treturn expr;\n\t\t}\n\t\tcatch (err:Dynamic)\n\t\t{\n\t\t\tContext.fatalError('Invalid JSX: ' + err, pos);\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tstatic function escapeJsx(jsx:String) \n\t{\n\t\tjsx = reInterpolationClass.replace(jsx, '$$1'); // '<$Item></$Item>' string interpolation\n\t\tjsx = reInterpolationVar.replace(jsx, '{$$1}'); // '$foo' string interpolation\n\t\tjsx = reInterpolationExpr.replace(jsx, '{'); // '${foo}' string interpolation\n\t\tjsx = reAttributeBinding.replace(jsx, '=\"$$1\"'); // attr={foo} escaping\n\t\treturn jsx;\n\t}\n\n\tstatic function parseJsxNode(xml:Xml, pos:Position)\n\t{\n\t\tvar args = [];\n\n\t\t// parse type\n\t\tvar path = xml.nodeName.split('.');\n\t\tvar last = path[path.length - 1];\n\t\tif (path.length == 1 && last.charAt(0) == last.charAt(0).toLowerCase()) args.push(macro $v{path[0]});\n\t\telse args.push(macro $p{path});\n\n\t\t// parse attributes\n\t\tvar attrs = [];\n\t\tfor (attr in xml.attributes())\n\t\t{\n\t\t\tvar value = xml.get(attr);\n\t\t\tvar expr = parseJsxExpr(value, pos);\n\t\t\tattrs.push({field:attr, expr:expr});\n\t\t}\n\t\tif (attrs.length == 0) args.push(macro null);\n\t\telse args.push({pos:pos, expr:EObjectDecl(attrs)});\n\n\t\tfor (node in xml)\n\t\t{\n\t\t\tif (node.nodeType == Xml.PCData)\n\t\t\t{\n\t\t\t\tvar value = StringTools.trim(node.toString());\n\t\t\t\tif (value.length == 0) continue;\n\n\t\t\t\tvar lines = ~/[\\r\\n]/g.split(value);\n\t\t\t\tlines = lines.map(StringTools.trim);\n\t\t\t\tfor (line in lines)\n\t\t\t\t{\n\t\t\t\t\tif (line.length == 0) continue;\n\t\t\t\t\t~/([^{]+|\\{[^}]+\\})/g.map(line, function (e){\n\t\t\t\t\t\tvar token = e.matched(0);\n\t\t\t\t\t\targs.push(parseJsxExpr(token, pos));\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (node.nodeType == Xml.Element)\n\t\t\t{\n\t\t\t\targs.push(parseJsxNode(node, pos));\n\t\t\t}\n\n\t\t}\n\t\treturn macro api.react.React.createElement($a{args});\n\t}\n\n\tstatic function parseJsxExpr(value:String, pos:Position)\n\t{\n\t\treturn if (value.charAt(0) == '{' && value.charAt(value.length - 1) == '}')\n\t\t{\n\t\t\tContext.parse(value.substr(1, value.length - 2), pos);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmacro $v{value};\n\t\t}\n\t}\n\t\n\tpublic static function setDisplayName()\n\t{\n\t\tvar fields = Context.getBuildFields();\n\t\t\n\t\tfor (field in fields) \n\t\t\tif (field.name == 'displayName') return fields;\n\t\t\n\t\tvar inClass = Context.getLocalClass().get();\n\t\tvar className = macro $v{inClass.name};\n\t\t\n\t\tvar field:Field = {\n\t\t\tname:'displayName',\n\t\t\taccess:[Access.AStatic, Access.APrivate],\n\t\t\tkind:FieldType.FVar(null, className),\n\t\t\tpos:Context.currentPos()\n\t\t}\n\t\tfields.push(field);\n\t\treturn fields;\n\t}\n\n\t#else\n\tpublic static macro function jsx(expr:ExprOf<String>):Expr\n\t{\n\t\treturn null;\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.macro;\n\nimport haxe.macro.Expr;\n\n/**\n\tThis class provides some utility methods to work with strings in macro\n\tcontext.\n**/\nclass MacroStringTools {\n\t#if macro\n\n\n\t/**\n\t\tFormats `String` `s` using the usual interpolation rules.\n\n\t\tThe returned expression is a concatenation of string parts and escaped\n\t\telements.\n\t**/\n\tstatic public function formatString(s:String, pos:Position) {\n\t\treturn Context.load(\"format_string\", 2)(untyped s.__s, pos);\n\t}\n\n\t/**\n\t\tTells if `e` is a format string, i.e. uses single quotes `'` as\n\t\tdelimiters.\n\n\t\tThis only works if `e` has a position which the compiler can find. While\n\t\tthis is true for any expressions appearing in real Haxe code (i.e. some\n\t\t.hx file), it might not work for expressions generated by macros.\n\n\t\tThis operation depends on the position of `e`.\n\t**/\n\tstatic public function isFormatExpr(e:ExprOf<String>) {\n\t\treturn Context.load(\"is_fmt_string\", 1)(e.pos);\n\t}\n\n\t#end\n\n\t/**\n\t\tConverts an array of Strings `sl` to a field expression.\n\n\t\tIf `sl` has no elements, the result is null.\n\n\t\tIf `sl` has one element, the result is `EConst(CIdent(sl[0])`.\n\n\t\tOtherwise the result is a chain of `EField` nodes.\n\n\t\tIf `sl` is null, the result is unspecified.\n\t**/\n\tstatic public function toFieldExpr(sl:Array<String>):Expr {\n\t\treturn Lambda.fold(sl, function(s, e) return e == null ? (macro $i{s}) : (macro $e.$s), null);\n\t}\n\n\t/**\n\t\tConverts a path given by package `pack` and name `name` to a `String`\n\t\tseparated by dots.\n\n\t\tIf `pack` has no elements, the result is `name`.\n\n\t\tIf `pack` is null, the result is unspecified.\n\n\t\tOtherwise the elements of `pack` are joined with a separating dot, with\n\t\tan appended dot separating the result from `name`.\n\t**/\n\tstatic public function toDotPath(pack:Array<String>, name:String):String {\n\t\treturn if (pack.length == 0) name else pack.join(\".\") + \".\" +name;\n\t}\n\n\tstatic public function toComplex( path : String ) : ComplexType {\n\t\tvar pack = path.split(\".\");\n\t\treturn TPath( { pack : pack, name : pack.pop(), params : [] } );\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator() : ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n\nprivate class ListIterator<T> {\n\tvar head:Array<Dynamic>;\n\tvar val:Dynamic;\n\n\tpublic inline function new(head:Array<Dynamic>) {\n\t\tthis.head = head;\n\t\tthis.val = null;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tval = head[0];\n\t\thead = head[1];\n\t\treturn val;\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\treturn untyped Function('return typeof $name != \"undefined\" ? $name : null')();\n\t}\n\n}\n","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nimport msignal.Slot;\n\n/**\n\tA convenience type describing any kind of signal.\n**/\ntypedef AnySignal = Signal<Dynamic, Dynamic>;\n\n/**\n\tA Signal manages a list of listeners, which are executed when the signal is \n\tdispatched.\n**/\nclass Signal<TSlot:Slot<Dynamic, Dynamic>, TListener>\n{\n\tpublic var valueClasses:Array<Dynamic>;\n\n\t/**\n\t\tThe current number of listeners for the signal.\n\t**/\n\tpublic var numListeners(get_numListeners, null):Int;\n\t\n\tvar slots:SlotList<TSlot, TListener>;\n\tvar priorityBased:Bool;\n\n\tfunction new(?valueClasses:Array<Dynamic>)\n\t{\n\t\tif (valueClasses == null) valueClasses = [];\n\t\tthis.valueClasses = valueClasses;\n\t\tslots = cast SlotList.NIL;\n\t\tpriorityBased = false;\n\t}\n\n\t/**\n\t\tSubscribes a listener for the signal.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function add(listener:TListener):TSlot\n\t{\n\t\treturn registerListener(listener);\n\t}\n\n\t/**\n\t\tSubscribes a one-time listener for this signal.\n\t\tThe signal will remove the listener automatically the first time it is called,\n\t\tafter the dispatch to all listeners is complete.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addOnce(listener:TListener):TSlot\n\t{\n\t\treturn registerListener(listener, true);\n\t}\n\n\t/**\n\t\tSubscribes a listener for the signal.\n\t\tAfter you successfully register an event listener,\n\t\tyou cannot change its priority through additional calls to add().\n\t\tTo change a listener's priority, you must first call remove().\n\t\tThen you can register the listener again with the new priority level.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addWithPriority(listener:TListener, ?priority:Int=0):TSlot\n\t{\n\t\treturn registerListener(listener, false, priority);\n\t}\n\n\t/**\n\t\tSubscribes a one-time listener for this signal.\n\t\tThe signal will remove the listener automatically the first time it is \n\t\tcalled, after the dispatch to all listeners is complete.\n\t\t\n\t\t@param listener A function matching the signature of TListener\n\t\t@return The added listener slot\n\t**/\n\tpublic function addOnceWithPriority(listener:TListener, ?priority:Int=0):TSlot\n\t{\n\t\treturn registerListener(listener, true, priority);\n\t}\n\n\t/**\n\t\tUnsubscribes a listener from the signal.\n\t\t\n\t\t@param listener The listener to remove\n\t\t@return The removed listener slot\n\t**/\n\tpublic function remove(listener:TListener):TSlot\n\t{\n\t\tvar slot = slots.find(listener);\n\t\tif (slot == null) return null;\n\t\t\n\t\tslots = slots.filterNot(listener);\n\t\treturn slot;\n\t}\n\n\t/**\n\t\tUnsubscribes all listeners from the signal.\n\t**/\n\tpublic function removeAll():Void\n\t{\n\t\tslots = cast SlotList.NIL;\n\t}\n\n\tfunction registerListener(listener:TListener, once:Bool=false, priority:Int=0):TSlot\n\t{\n\t\tif (registrationPossible(listener, once))\n\t\t{\n\t\t\tvar newSlot = createSlot(listener, once, priority);\n\t\t\t\n\t\t\tif (!priorityBased && priority != 0) priorityBased = true;\n\t\t\tif (!priorityBased && priority == 0) slots = slots.prepend(newSlot);\n\t\t\telse slots = slots.insertWithPriority(newSlot);\n\n\t\t\treturn newSlot;\n\t\t}\n\t\t\n\t\treturn slots.find(listener);\n\t}\n\n\tfunction registrationPossible(listener, once)\n\t{\n\t\tif (!slots.nonEmpty) return true;\n\t\t\n\t\tvar existingSlot = slots.find(listener);\n\t\tif (existingSlot == null) return true;\n\n\t\tif (existingSlot.once != once)\n\t\t{\n\t\t\t// If the listener was previously added, definitely don't add it again.\n\t\t\t// But throw an exception if their once values differ.\n\t\t\tthrow \"You cannot addOnce() then add() the same listener without removing the relationship first.\";\n\t\t}\n\t\t\n\t\treturn false; // Listener was already registered.\n\t}\n\n\t@:IgnoreCover\n\tfunction createSlot(listener:TListener, once:Bool=false, priority:Int=0):TSlot\n\t{\n\t\treturn null;\n\t}\n\n\tfunction get_numListeners()\n\t{\n\t\treturn slots.length;\n\t}\n}\n\n/**\n\tSignal that executes listeners with no arguments.\n**/\nclass Signal0 extends Signal<Slot0, Void -> Void>\n{\n\tpublic function new()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with no arguements.\n\t**/\n\tpublic function dispatch()\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute();\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:Void -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\treturn new Slot0(this, listener, once, priority);\n\t}\n}\n\n/**\n\tSignal that executes listeners with one arguments.\n**/\nclass Signal1<TValue> extends Signal<Slot1<TValue>, TValue -> Void>\n{\n\tpublic function new(?type:Dynamic=null)\n\t{\n\t\tsuper([type]);\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with one arguement.\n\t**/\n\tpublic function dispatch(value:TValue)\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute(value);\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:TValue -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\treturn new Slot1<TValue>(this, listener, once, priority);\n\t}\n}\n\n/**\n\tSignal that executes listeners with two arguments.\n**/\nclass Signal2<TValue1, TValue2> extends Signal<Slot2<TValue1, TValue2>, TValue1 -> TValue2 -> Void>\n{\n\tpublic function new(?type1:Dynamic=null, ?type2:Dynamic=null)\n\t{\n\t\tsuper([type1, type2]);\n\t}\n\n\t/**\n\t\tExecutes the signals listeners with two arguements.\n\t**/\n\tpublic function dispatch(value1:TValue1, value2:TValue2)\n\t{\n\t\tvar slotsToProcess = slots;\n\t\t\n\t\twhile (slotsToProcess.nonEmpty)\n\t\t{\n\t\t\tslotsToProcess.head.execute(value1, value2);\n\t\t\tslotsToProcess = slotsToProcess.tail;\n\t\t}\n\t}\n\n\toverride function createSlot(listener:TValue1 -> TValue2 -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\treturn new Slot2<TValue1, TValue2>(this, listener, once, priority);\n\t}\n}\n","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nimport msignal.Signal;\n\n/**\n\tA convenience type describing any kind of slot.\n**/\ntypedef AnySlot = Slot<Dynamic, Dynamic>;\n\n/**\n\tDefines the basic properties of a listener associated with a Signal.\n**/\n#if haxe3\nclass Slot<TSignal:msignal.Signal.AnySignal, TListener>\n#else\nclass Slot<TSignal:Signal<Dynamic, TListener>, TListener>\n#end\n{\n\t/**\n\t\tThe listener associated with this slot.\n\t\tNote: for hxcpp 2.10 this requires a getter method to compile\n\t**/\n\t#if cpp\n\t#if haxe3 @:isVar #end\n\tpublic var listener(get_listener, set_listener):TListener;\n\t#else\n\t#if haxe3 @:isVar #end\n\tpublic var listener(default, set_listener):TListener;\n\t#end\n\t\n\n\t/**\n\t\tWhether this slot is automatically removed after it has been used once.\n\t**/\n\tpublic var once(default, null):Bool;\n\n\t/**\n\t\tThe priority of this slot should be given in the execution order.\n\t\tAn Signal will call higher numbers before lower ones.\n\t\tDefaults to 0.\n\t**/\n\tpublic var priority(default, null):Int;\n\n\t/**\n\t\tWhether the listener is called on execution. Defaults to true.\n\t**/\n\tpublic var enabled:Bool;\n\n\tvar signal:TSignal;\n\t\n\tfunction new(signal:TSignal, listener:TListener, once:Bool=false, priority:Int=0)\n\t{\n\t\tthis.signal = signal;\n\t\tthis.listener = listener;\n\t\tthis.once = once;\n\t\tthis.priority = priority;\n\t\tthis.enabled = true;\n\t}\n\n\t/**\n\t\tRemoves the slot from its signal.\n\t**/\n\tpublic function remove()\n\t{\n\t\tsignal.remove(listener);\n\t}\n\n\t#if cpp\n\t/**\n\t\tHxcpp 2.10 requires a getter method for a typed function property in \n\t\torder to compile\n\t**/\n\tfunction get_listener():TListener\n\t{\n\t\treturn listener;\n\t}\n\t#end\n\n\tfunction set_listener(value:TListener):TListener\n\t{\n\t\tif (value == null) throw \"listener cannot be null\";\n\t\treturn listener = value;\n\t}\n}\n\n/**\n\tA slot that executes a listener with no arguments.\n**/\nclass Slot0 extends Slot<Signal0, Void -> Void>\n{\n\tpublic function new(signal:Signal0, listener:Void -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with no arguments.\n\t**/\n\tpublic function execute()\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\tlistener();\n\t}\n}\n\n/**\n\tA slot that executes a listener with one argument.\n**/\nclass Slot1<TValue> extends Slot<Signal1<TValue>, TValue -> Void>\n{\n\t/**\n\t\tAllows the slot to inject the argument to dispatch.\n\t**/\n\tpublic var param:TValue;\n\n\tpublic function new(signal:Signal1<TValue>, listener:TValue -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with one argument.\n\t\tIf <code>param</code> is not null, it overrides the value provided.\n\t**/\n\tpublic function execute(value1:TValue)\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\tif (param != null) value1 = param;\n\t\tlistener(value1);\n\t}\n}\n\n/**\n\tA slot that executes a listener with two arguments.\n**/\nclass Slot2<TValue1, TValue2> extends Slot<Signal2<TValue1, TValue2>, TValue1 -> TValue2 -> Void>\n{\n\t/**\n\t\tAllows the slot to inject the first argument to dispatch.\n\t**/\n\tpublic var param1:TValue1;\n\n\t/**\n\t\tAllows the slot to inject the second argument to dispatch.\n\t**/\n\tpublic var param2:TValue2;\n\n\tpublic function new(signal:Signal2<TValue1, TValue2>, listener:TValue1 -> TValue2 -> Void, once:Bool=false, priority:Int=0)\n\t{\n\t\tsuper(signal, listener, once, priority);\n\t}\n\n\t/**\n\t\tExecutes a listener with two arguments.\n\t\tIf <code>param1</code> or <code>param2</code> is set, \n\t\tthey override the values provided.\n\t**/\n\tpublic function execute(value1:TValue1, value2:TValue2)\n\t{\n\t\tif (!enabled) return;\n\t\tif (once) remove();\n\t\t\n\t\tif (param1 != null) value1 = param1;\n\t\tif (param2 != null) value2 = param2;\n\t\t\n\t\tlistener(value1, value2);\n\t}\n}\n","/*\nCopyright (c) 2012 Massive Interactive\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n*/\n\npackage msignal;\n\nclass SlotList<TSlot:Slot<Dynamic, Dynamic>, TListener>\n{\n\t@:IgnoreCover\n\tstatic function __init__() { NIL = new SlotList<Dynamic, Dynamic>(null, null); }\n\t\n\t/**\n\t\tRepresents an empty list. Used as the list terminator.\n\t**/\n\tpublic static var NIL:SlotList<Dynamic, Dynamic>;\n\t\n\tpublic var head:TSlot;\n\tpublic var tail:SlotList<TSlot, TListener>;\n\tpublic var nonEmpty:Bool;\n\t\n\t/**\n\t\tCreates and returns a new SlotList object.\n\n\t\t<p>A user never has to create a SlotList manually. \n\t\tUse the <code>NIL</code> element to represent an empty list. \n\t\t<code>NIL.prepend(value)</code> would create a list containing \n\t\t<code>value</code></p>.\n\n\t\t@param head The first slot in the list.\n\t\t@param tail A list containing all slots except head.\n\t**/\n\tpublic function new(head:TSlot, tail:SlotList<TSlot, TListener>=null)\n\t{\n\t\tnonEmpty = false;\n\t\t\n\t\tif (head == null && tail == null)\n\t\t{\n\t\t\tif (NIL != null)\n\t\t\t{\n\t\t\t\tthrow \"Parameters head and tail are null. Use the NIL element instead.\";\n\t\t\t}\n\t\t\t\n\t\t\t// this is the NIL element as per definition\n\t\t\tnonEmpty = false;\n\t\t}\n\t\telse if (head == null)\n\t\t{\n\t\t\tthrow \"Parameter head cannot be null.\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.head = head;\n\t\t\tthis.tail = (tail == null ? cast NIL : tail);\n\t\t\tnonEmpty = true;\n\t\t}\n\t}\n\t\n\t/**\n\t\tThe number of slots in the list.\n\t**/\n\tpublic var length(get_length, null):Int;\n\tfunction get_length():Int\n\t{\n\t\tif (!nonEmpty) return 0;\n\t\tif (tail == NIL) return 1;\n\t\t\n\t\t// We could cache the length, but it would make methods like filterNot unnecessarily complicated.\n\t\t// Instead we assume that O(n) is okay since the length property is used in rare cases.\n\t\t// We could also cache the length lazy, but that is a waste of another 8b per list node (at least).\n\t\t\n\t\tvar result = 0;\n\t\tvar p = this;\n\t\t\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\t++result;\n\t\t\tp = p.tail;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t\tPrepends a slot to this list.\n\t\t@param\tslot The item to be prepended.\n\t\t@return\tA list consisting of slot followed by all elements of this list.\n\t**/\n\tpublic function prepend(slot:TSlot)\n\t{\n\t\treturn new SlotList<TSlot, TListener>(slot, this);\n\t}\n\t\n\t/**\n\t\tAppends a slot to this list.\n\t\tNote: appending is O(n). Where possible, prepend which is O(1).\n\t\tIn some cases, many list items must be cloned to \n\t\tavoid changing existing lists.\n\t\t@param\tslot The item to be appended.\n\t\t@return\tA list consisting of all elements of this list followed by slot.\n\t**/\n\tpublic function append(slot:TSlot)\n\t{\n\t\tif (slot == null) return this;\n\t\tif (!nonEmpty) return new SlotList<TSlot, TListener>(slot);\n\t\t\n\t\t// Special case: just one slot currently in the list.\n\t\tif (tail == NIL) \n\t\t{\n\t\t\treturn new SlotList<TSlot, TListener>(slot).prepend(head);\n\t\t}\n\t\t\n\t\t// The list already has two or more slots.\n\t\t// We have to build a new list with cloned items because they are immutable.\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\t\t\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// Append the new slot last.\n\t\tsubClone.tail = new SlotList<TSlot, TListener>(slot);\n\t\treturn wholeClone;\n\t}\t\t\n\t\n\t/**\n\t\tInsert a slot into the list in a position according to its priority.\n\t\tThe higher the priority, the closer the item will be inserted to the \n\t\tlist head.\n\t\t@param slot The item to be inserted.\n\t**/\n\tpublic function insertWithPriority(slot:TSlot)\n\t{\n\t\tif (!nonEmpty) return new SlotList<TSlot, TListener>(slot);\n\t\t\n\t\tvar priority:Int = slot.priority;\n\t\t\n\t\t// Special case: new slot has the highest priority.\n\t\tif (priority >= this.head.priority) return prepend(slot);\n\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\n\t\t// Find a slot with lower priority and go in front of it.\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tif (priority > current.head.priority)\n\t\t\t{\n\t\t\t\tsubClone.tail = current.prepend(slot);\n\t\t\t\treturn wholeClone;\n\t\t\t}\n\t\t\t\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// Slot has lowest priority.\n\t\tsubClone.tail = new SlotList<TSlot, TListener>(slot);\n\t\treturn wholeClone;\n\t}\n\t\n\t/**\n\t\tReturns the slots in this list that do not contain the supplied \n\t\tlistener. Note: assumes the listener is not repeated within the list.\n\t\t@param\tlistener The function to remove.\n\t\t@return A list consisting of all elements of this list that do not \n\t\t\t\thave listener.\n\t**/\n\tpublic function filterNot(listener:TListener)\n\t{\n\t\tif (!nonEmpty || listener == null) return this;\n\t\t\n\t\tif (Reflect.compareMethods(head.listener, listener)) return tail;\n\t\t\n\t\t// The first item wasn't a match so the filtered list will contain it.\n\t\tvar wholeClone = new SlotList<TSlot, TListener>(head);\n\t\tvar subClone = wholeClone;\n\t\tvar current = tail;\n\t\t\n\t\twhile (current.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(current.head.listener, listener))\n\t\t\t{\n\t\t\t\t// Splice out the current head.\n\t\t\t\tsubClone.tail = current.tail;\n\t\t\t\treturn wholeClone;\n\t\t\t}\n\t\t\t\n\t\t\tsubClone = subClone.tail = new SlotList<TSlot, TListener>(current.head);\n\t\t\tcurrent = current.tail;\n\t\t}\n\t\t\n\t\t// The listener was not found so this list is unchanged.\n\t\treturn this;\n\t}\n\t\n\t/**\n\t\tDetermines whether the supplied listener Function is contained \n\t\twithin this list\n\t**/\n\tpublic function contains(listener:TListener):Bool\n\t{\n\t\tif (!nonEmpty) return false;\n\n\t\tvar p = this;\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(p.head.listener, listener)) return true;\n\t\t\tp = p.tail;\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\t/**\n\t\tRetrieves the Slot associated with a supplied listener within the SlotList.\n\t\t@param   listener The Function being searched for\n\t\t@return  The ISlot in this list associated with the listener parameter \n\t\t\t\t through the ISlot.listener property. Returns null if no such \n\t\t\t\t ISlot instance exists or the list is empty.  \n\t**/\n\tpublic function find(listener:TListener):TSlot\n\t{\n\t\tif (!nonEmpty) return null;\n\t\t\n\t\tvar p = this;\n\t\twhile (p.nonEmpty)\n\t\t{\n\t\t\tif (Reflect.compareMethods(p.head.listener, listener)) return p.head;\n\t\t\tp = p.tail;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}\n","/**\n  This is a primitive asynchronous class, used as a base class for Promise and\n  Signal.\n **/\n\n\npackage promhx.base;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.Thenable;\n\ntypedef AsyncLink<T> = {\n    async : AsyncBase<Dynamic>,\n    linkf : T->Void\n}\n\n\nclass AsyncBase<T>{\n#if debug\n    // add ids to the async instances so they are easier to track\n    static var id_ctr  = 0;\n    var id          : Int;\n#end\n    var _val        : T;\n    var _resolved   : Bool;\n    var _fulfilled  : Bool;\n    var _pending    : Bool;\n    var _update     : Array<AsyncLink<T>>;\n    var _error      : Array<Dynamic->Void>;\n    var _errored    : Bool;\n    var _errorMap   : Dynamic->T;\n    var _errorVal   : Dynamic;\n    var _errorPending : Bool;\n\n    public function new(?d:Deferred<T>) {\n#if debug id = id_ctr +=1; #end\n        _resolved   = false;\n        _pending = false;\n        _errorPending = false;\n        _fulfilled  = false;\n        _update     = [];\n        _error      = [];\n        _errored    = false;\n\n        if (d != null){\n            link(d,this, function(x) return x);\n        }\n\n    }\n\n    /**\n      Catch error, effectively halting the current update chain.\n      This will prevent downstream async objects from receiving\n      the error message.\n     **/\n    public function catchError(f : Dynamic->Void) {\n        _error.push(f);\n        return this;\n    }\n\n    /**\n      Map errors back to the expected type, and continue as normal.\n     **/\n    public function errorThen( f : Dynamic -> T){\n        _errorMap = f;\n        return this;\n    }\n\n    /**\n      Utility function to determine if a Promise value has been resolved.\n     **/\n    public inline function isResolved() : Bool\n        return _resolved;\n\n    /**\n      Utility function to determine if a Promise value is in an error state.\n     **/\n    public inline function isErrored() : Bool\n        return _errored;\n\n    /**\n      Utility function to determine if a Promise has handled the error.\n     **/\n    public inline function isErrorHandled() : Bool\n        return _error.length > 0;\n\n    /**\n      Utility function to determine if a Promise error is pending.\n     **/\n    public inline function isErrorPending() : Bool\n        return _errorPending;\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isFulfilled(): Bool\n        return _fulfilled;\n\n    /**\n      Utility function to determine if a Promise value is pending operations\n      on the next loop.\n     **/\n    public inline function isPending() : Bool\n        return _pending;\n\n\n    function handleResolve(val:T) : Void {\n        _resolve(val);\n    }\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    function _resolve(val : T) : Void {\n\n        // this async is pending an update on the next loop, move the\n        // resolve to the loop after that.\n        if (_pending){\n            EventLoop.enqueue(_resolve.bind(val));\n        } else {\n\n            // point of no return, this async has now been resolved at least once.\n            _resolved = true;\n\n            // we are now in the act of fulfilling the async... which\n            // involves waiting for the next enqueued loop\n            _pending = true;\n\n            // the loop handler, which may not even be used\n            EventLoop.enqueue(function(){\n                _val = val; // save the value\n                for (up in _update){\n#if PromhxExposeErrors\n                    up.linkf(val);\n#else\n                    try up.linkf(val)\n                catch (e:Dynamic) up.async.handleError(e);\n#end\n                }\n                _fulfilled = true; // we're in a fulfilled state\n                _pending = false; // we're done fulfilling for this resolve\n            });\n        }\n\n    }\n\n    /**\n      Handle errors, can be overridden\n     **/\n    function handleError(error : Dynamic) : Void {\n        _handleError(error);\n    }\n\n    function _handleError(error : Dynamic) : Void {\n        var update_errors = function(e:Dynamic){\n            if (_error.length > 0) for (ef in _error) ef(e);\n            else if (_update.length > 0) for (up in _update) up.async.handleError(e);\n            else {\n#if (js && nodejs)\n                // Node sometimes doesn't produce helpful stack information on thrown errors.\n                trace('Call Stack: ' + haxe.CallStack.toString(haxe.CallStack.callStack()));\n#end\n                throw e;\n            }\n            this._errorPending = false;\n        }\n        if (!_errorPending){\n            _errorPending = true;\n            _errored = true;\n            _errorVal = error;\n\n            EventLoop.enqueue(function(){\n                if (_errorMap != null){\n#if PromhxExposeErrors\n                    this._resolve(_errorMap(error));\n                    _resolve(_errorMap(error));\n#else\n                    try this._resolve(_errorMap(error))\n                        catch (e : Dynamic) update_errors(e);\n#end\n                } else {\n                    update_errors(error);\n                }\n            });\n        }\n    }\n\n    /**\n      This function returns a new AsyncBase.  When this instance resolves,\n      it will resolve the new AsyncBase with the function callback argument.\n     **/\n    public function then<A>(f : T->A) : AsyncBase<A> {\n        var ret = new AsyncBase<A>();\n        link(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Remove an Async that is updated from this Async.  This action is\n      performed on the next event loop.\n     **/\n    public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            _update =  _update.filter(function(x) return x.async != to);\n        });\n    }\n\n    /**\n      Determine if an Async is updated from this Async.\n     **/\n    public function isLinked( to : AsyncBase<Dynamic>) : Bool {\n        var updated = false;\n        for (u in _update) if (u.async == to) return true;\n        return updated;\n    }\n\n\n    /**\n      This is the base \"link\" method for wiring up the \"current\" async to\n      the \"next\" one via the transform defined by the f argument.\n     **/\n    inline public static function link<A,B>\n        (current : AsyncBase<A>, next: AsyncBase<B>, f : A->B) : Void\n    {\n        // the function wrapper for the callback, which will resolve the return\n        // if current is not resolved, or will resolve next loop, push to\n        // update queues.\n        current._update.push({\n            async : next,\n            linkf : function(x){\n                next.handleResolve(f(x));\n            }\n        });\n        immediateLinkUpdate(current, next, f);\n    }\n\n    static function immediateLinkUpdate<A,B>\n        (current : AsyncBase<A>, next : AsyncBase<B>, f : A->B) : Void\n    {\n        if (current.isErrored()  // is there an error?\n                && !current.isErrorPending()  // if the error is pending, we can rely on current to update this async on the next loop.\n                && !current.isErrorHandled() ) // if the error is handled by current, we'll ignore it.\n                    next.handleError(current._errorVal);\n\n        // then the value\n        if (current.isResolved() && !current.isPending()){\n            // we can go ahead and resolve this.\n#if PromhxExposeErrors\n            next.handleResolve(f(current._val));\n#else\n            try next.handleResolve(f(current._val))\n            catch (e:Dynamic) next.handleError(e);\n#end\n        }\n\n    }\n\n    inline public static function linkAll<T>\n        (all : Iterable<AsyncBase<T>>, next: AsyncBase<Array<T>>) : Void\n    {\n        // a helper callback function.  This will be called for each Stream in\n        // the iterable argument.  The \"arr\" argument will be all of the Streams\n        // *except* the one currently resolving.  If there's only one Stream\n        // in the iterable, it will always resolve.\n        var cthen = function(arr:Array<AsyncBase<T>>, current:AsyncBase<T>,  v){\n            if (arr.length == 0 || AsyncBase.allFulfilled(arr)){\n                var vals = [for (a in all) a == current ? v : a._val];\n                next.handleResolve(vals);\n            }\n            return null;\n        };\n        for (a in all){\n            a._update.push({\n                async : next,\n                linkf: cthen.bind([for (a2 in all) if (a2 != a) a2], a, _)\n            });\n        }\n\n        if (AsyncBase.allFulfilled(all)) {\n            next.handleResolve([for (a in all) a._val]);\n        }\n    }\n\n    /**\n      Similar to the link function, except the [f] function must return an\n      AsyncBase instance.\n     **/\n    inline static public function pipeLink<A,B>\n        ( current : AsyncBase<A>, ret : AsyncBase<B>, f : A->AsyncBase<B> ) : Void\n    {\n        var linked = false;\n        var linkf = function(x){ // updates go to pipe function.\n                if (!linked){ // but only once\n                    linked = true; // the piped async doesn't actually respond to updates from current\n                    var pipe_ret = f(x); // it just needs to be created\n                    pipe_ret._update.push({  // and to be linked to ret\n                        async : ret, // errors go to ret\n                        linkf : ret.handleResolve // updates go directly to ret\n                    });\n                    immediateLinkUpdate(pipe_ret, ret, function(x) return x );\n                }\n            }\n\n        current._update.push({\n            async : ret, // errors go to ret\n            linkf : linkf\n        });\n\n        if (current.isResolved() && !current.isPending()){\n#if PromhxExposeErrors\n            linkf(current._val);\n#else\n            try linkf(current._val)\n            catch (e:Dynamic) ret.handleError(e);\n#end\n        }\n    }\n\n    /**\n      Utility function to determine if all Promise values are set.\n     **/\n    public static function allResolved\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isResolved()) return false;\n        }\n        return true;\n    }\n\n    /**\n      Utility function to determine if all Promise values are resolved and\n      are currently fulfilled (not in the process of fulfilling).\n     **/\n    static function allFulfilled\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isFulfilled()) return false;\n        }\n        return true;\n    }\n\n}\n","package promhx;\nimport promhx.base.AsyncBase;\n\n@:expose\nclass Deferred<T> extends AsyncBase<T> {\n\n    public function new() super();\n\n    /**\n      The public write interface\n     **/\n    public function resolve(val:T) handleResolve(val);\n\n    inline public function throwError(e:Dynamic) handleError(e);\n\n    /**\n      Returns a new promise based on the current deferred instance\n     **/\n    public function promise(){\n        return new Promise(this);\n    }\n\n    /**\n      Returns a new stream based on the current deferred instance\n     **/\n    public function stream(){\n        return new Stream(this);\n    }\n\n    /**\n      Returns a stream based on the current deferred instance\n     **/\n    public function publicStream(){\n        return new PublicStream(this);\n    }\n}\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport promhx.error.PromiseError;\n\n@:expose\nclass Promise<T> extends AsyncBase<T>{\n    var _rejected   : Bool;\n    public function new(?d:Deferred<T>){\n        super(d);\n        _rejected = false;\n    }\n\n    /**\n      Macro method that binds the promise arguments to a single function\n      callback that is triggered when all promises are resolved.\n      Note: You may call this function on as many promise arguments as you\n      like.\n     **/\n    macro public static function when<T>( args : Array<ExprOf<Promise<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved promise values\n        var epargs = [for (i in 0...args.length) macro arr[$v{i}]._val];\n\n        // the returned function that actually does the runtime work.\n        return macro @:privateAccess {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the promises with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new promise for return.\n                // this new promise resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved promise values.\n                var ret = new promhx.Promise();\n                var arr : Array<promhx.Promise<Dynamic>> = $eargs;\n                var p = promhx.Promise.whenAll(arr);\n                p._update.push({\n                    async : ret,\n                    linkf : function(x) ret.handleResolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isRejected(): Bool {\n        return _rejected;\n    }\n\n    /**\n      Rejects the promise, throwing an error.\n     **/\n    public function reject(e : Dynamic): Void {\n        _rejected = true;\n        handleError(e);\n    }\n\n    /**\n      Transforms an iterable of promises into a single promise which resolves\n      to an array of values.\n     **/\n    public static function whenAll<T>(itb : Iterable<Promise<T>>) : Promise<Array<T>> {\n        var ret : Promise<Array<T>> = new Promise();\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    override function handleResolve(val : T): Void {\n        if (_resolved) {\n            var msg = \"Promise has already been resolved\";\n            throw(AlreadyResolved(msg));\n        }\n        _resolve(val);\n    }\n\n    /**\n      add a wait function directly to the Promise instance.\n     **/\n    override public function then<A>(f : T->A): Promise<A> {\n        var ret  = new Promise<A>();\n        AsyncBase.link(this, ret, f);\n        return ret;\n    }\n\n    override public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            if (!isFulfilled()) {\n                var msg = \"Downstream Promise is not fullfilled\";\n                handleError(DownstreamNotFullfilled(msg));\n            }\n            else{\n                _update =  _update.filter(function(x) return x.async != to);\n            }\n        });\n    }\n\n    override function handleError(error : Dynamic) : Void {\n       _rejected = true; \n       _handleError(error);\n    }\n\n    public function pipe<A>(f : T->Promise<A>) : Promise<A> {\n        var ret = new Promise<A>();\n        AsyncBase.pipeLink(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Pipes an error back into a normal type.\n      **/\n    public function errorPipe( f: Dynamic-> Promise<T>){\n        var ret = new Promise<T>();\n        catchError(function(e){\n            var piped = f(e);\n            piped.then(ret._resolve);\n        });\n        then(ret._resolve);\n        return ret;\n    }\n\n    /**\n      Converts any value to a resolved Promise\n     **/\n    public static function promise<T>(_val : T): Promise<T> {\n        var ret = new Promise<T>();\n        ret.handleResolve(_val);\n        return ret;\n    }\n}\n\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport haxe.ds.Option;\n\n@:expose\nclass Stream<T> extends AsyncBase<T> {\n    var deferred      : Deferred<T>;\n    var _pause        : Bool;\n    var _end          : Bool;\n    var _end_promise  : Promise<Option<T>>;\n    var _end_deferred : Deferred<Option<T>>;\n\n    public function new(?d : Deferred<T>){\n        super(d);\n        _end_deferred = new Deferred<Option<T>>();\n        _end_promise = _end_deferred.promise();\n    }\n\n    /**\n      Macro method that binds the stream arguments to a single function\n      callback that is triggered when all streams are updated.\n      Note: You may call this function on as many stream arguments as you\n      like.\n     **/\n    macro public static function whenever<T>( args : Array<ExprOf<AsyncBase<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved stream values\n        var epargs = [for (i in 0...args.length) macro arr[$v{i}]._val];\n\n        // the returned function that actually does the runtime work.\n        return macro @:privateAccess {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the streams with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new stream for return.\n                // this new stream resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved stream values.\n                var ret = new promhx.Stream();\n                var arr : Array<promhx.base.AsyncBase<Dynamic>> = $eargs;\n                var p = promhx.Stream.wheneverAll(arr);\n                p._update.push({\n                    async: ret,\n                    linkf: function(x) ret.handleResolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Creates a stream from the iterable [itb] that will immediately update\n      for each value, and then end.\n     **/\n    public static function foreach<T>(itb : Iterable<T>) : Stream<T> {\n        var s = new Stream<T>();\n        for (i in itb) s.handleResolve(i);\n        s.end();\n        return s;\n    }\n\n\n    /**\n      add a wait function directly to the Stream instance.\n     **/\n    override public function then<A>(f : T->A) : Stream<A> {\n        var ret  = new Stream<A>();\n        AsyncBase.link(this, ret, f);\n        _end_promise.then(function(x) ret.end());\n        return ret;\n    }\n\n    public function detachStream(str : Stream<Dynamic>) : Bool {\n        var filtered = [];\n        var removed = false;\n        for (u in _update){\n            if (u.async == str)  removed = true;\n            else filtered.push(u);\n        }\n        _update = filtered;\n        return removed;\n    }\n\n    /**\n      Transforms an iterable of streams into a single stream which resolves\n      to an array of values.\n     **/\n    public static function wheneverAll<T>(itb : Iterable<AsyncBase<T>>) : Stream<Array<T>> {\n        var ret = new Stream<Array<T>>();\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Concatenates all the streams in the iterable argument to a single stream.  See\n      the [concat] instance method.\n     **/\n    public static function concatAll<T>(itb : Iterable<Stream<T>>) : Stream<T> {\n        var ret = new Stream<T>();\n        for (i in itb) ret.concat(i);\n        return ret;\n    }\n\n    /**\n      Merges all the streams in the iterable argument to a single stream.  See\n      the [merge] instance method.\n     **/\n    public static function mergeAll<T>(itb : Iterable<Stream<T>>) : Stream<T> {\n        var ret = new Stream<T>();\n        for (i in itb) ret.merge(i);\n        return ret;\n    }\n\n    /**\n      Returns a Promise that will resolve only for the first stream update.\n     **/\n    public inline function first() : Promise<T> {\n        var s = new Promise<T>();\n        then(function(x) if (!s.isResolved()) s.handleResolve(x));\n        return s;\n    }\n\n    override function handleResolve(val : T) : Void {\n        if (!_end && !_pause) _resolve(val);\n    }\n\n    /**\n      Momentarily disable updates for the stream.  Set the pause state with\n      the argument.  Call it without the argument to toggle the current state.\n     **/\n    public function pause(?set : Bool){\n        if (set == null) set = !_pause;\n        _pause = set;\n    }\n\n    public function pipe<A>(f : T->Stream<A>) : Stream<A> {\n        var ret = new Stream<A>();\n        AsyncBase.pipeLink(this, ret, f);\n        _end_promise.then(function(x) ret.end());\n        return ret;\n    }\n\n    /**\n      Pipes an error back into a normal type.\n      **/\n    public function errorPipe( f: Dynamic-> Stream<T>) : Stream<T>{\n        var ret = new Stream<T>();\n        catchError(function(e){\n            var piped = f(e);\n            piped.then(ret._resolve);\n            piped._end_promise.then(ret._end_promise._resolve);\n        });\n        then(ret._resolve);\n        _end_promise.then(function(x) ret.end());\n        return ret;\n    }\n\n    /**\n      I need this as a private function to call recursively.\n     **/\n    function handleEnd(){\n        // If the async is still pending, check on the next loop.\n        if (isPending()) EventLoop.enqueue(handleEnd);\n        else if (_end_promise.isResolved()) return;\n        else {\n            _end = true;\n            var o = isResolved() ? Some(_val) : None;\n            _end_promise.handleResolve(o);\n            _update = [];\n            _error = [];\n        }\n    }\n\n    public function end(){\n        EventLoop.enqueue(handleEnd);\n        return this;\n    }\n\n    inline public function endThen<A>(f : Option<T>->A) : Promise<A>{\n       return _end_promise.then(f);\n    }\n\n    /**\n      Creates a new stream linked to the current instance that only updates\n      if the [f] argument is true.\n     **/\n    public function filter(f : T->Bool) : Stream<T>{\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : function(x) if (f(x)) ret.handleResolve(x)\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        return ret;\n    }\n\n    /**\n      Creates a new stream that updates with the values from the current\n      stream until the stream ends, and then takes values from the next stream\n      [s] until that stream ends.\n     **/\n    public function concat(s : Stream<T>) : Stream<T> {\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        endThen(function(_){\n            s.pipe(function(x){\n                ret.handleResolve(x);\n                return ret;\n            });\n            s.endThen(function(_){\n                ret.end();\n            });\n        });\n        return ret;\n    }\n\n    /**\n      Merges another stream into the current one.\n     **/\n    public function merge(s : Stream<T>) : Stream<T> {\n        var ret = new Stream<T>();\n        _update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        s._update.push({\n            async : ret,\n            linkf : ret.handleResolve\n        });\n        AsyncBase.immediateLinkUpdate(this, ret, function(x) return x);\n        AsyncBase.immediateLinkUpdate(s, ret, function(x) return x);\n        return ret;\n    }\n\n    /**\n      Converts any value to a resolved Stream\n     **/\n    public static function stream<A>(_val : A): Stream<A> {\n        var ret = new Stream<A>();\n        ret.handleResolve(_val);\n        return ret;\n    }\n\n}\n\n","\npackage promhx;\n\n@:expose\nclass PublicStream<T> extends Stream<T> {\n    public function new(?def : Deferred<T>){\n        super(def);\n    }\n    inline public function resolve(val:T) this.handleResolve(val);\n    inline public function throwError(e:Dynamic) handleError(e);\n    inline public function update(val:T) this.handleResolve(val);\n    inline public static function publicstream<T>(val:T){\n        var ps = new PublicStream();\n        ps.resolve(val);\n        return ps;\n    }\n}\n","package promhx.base;\n\nprivate typedef Queue = #if java java.vm.AtomicList #else List #end <Void->Void>;\n\nclass EventLoop {\n    static var queue : Queue = new Queue();\n\n    // public static var nextLoop(default, set) : (Void->Void)-> Void;\n    public static var nextLoop : (Void->Void)-> Void;\n\n#if (js && !nodejs && !noEmbedJs && !noEmbedSetImmediate)\n    static function __init__() untyped {\n#if !nodejs\n        // we need to use global as an alternate since setImmediate expects this == window\n        var global = window;\n#end\n        haxe.macro.Compiler.includeFile(\"lib/setImmediate/setImmediate.js\");\n    }\n#end\n\n    public static inline function enqueue(eqf:Void->Void)  {\n        queue.add(eqf);\n        continueOnNextLoop();\n    }\n    static function set_nextLoop(f : (Void->Void)->Void) : (Void->Void)->Void{\n        if (nextLoop != null) throw \"nextLoop has already been set\";\n        else nextLoop = f;\n        return nextLoop;\n    }\n\n    /**\n      Retrieve the current length of the queue.\n     **/\n    public static inline function queueEmpty() {\n        return #if java queue.peekLast() == null #else queue.isEmpty() #end;\n    }\n\n    /**\n      Attempt to finish the remaining loops in the queue.  Returns true\n      if all loops are finished.  If [max_iterations] pass, then exit and\n      return false.\n     **/\n    public static function finish(max_iterations = 1000){\n        var fn = null;\n        while (max_iterations-- > 0 && (fn = queue.pop()) != null){\n            fn();\n        }\n        return queueEmpty();\n    }\n\n    /**\n      Clear the existing event loop queue.\n     **/\n    public static function clear(){\n        queue = new Queue();\n    }\n\n    static function f(){\n        var fn = queue.pop();\n        if (fn != null) fn();\n        if (!queueEmpty()) continueOnNextLoop();\n    }\n\n    static function continueOnNextLoop(){\n        if (nextLoop != null) nextLoop(f);\n        else {\n\n#if flash\n            haxe.Timer.delay(f,0);\n#elseif (js && (noEmbedJs || noEmbedSetImmediate) && !nodejs)\n            // fallback to setTimeout\n            untyped __js__(\"(typeof setImmediate === 'function' ? setImmediate : setTimeout)\")(f);\n#elseif js\n            // use polyfill or native node\n            untyped __js__(\"setImmediate\")(f);\n#else\n            f();\n#end\n        }\n    }\n}\n","package stores;\r\n\r\nimport msignal.Signal;\r\n\r\nimport Ajax;\r\nimport Ajax.HTTPMethod;\r\nimport Ajax.Response;\r\n\r\nclass ListStore {\r\n\tprivate function new(){}\r\n\tpublic static var files(default, null):Array<String>;\r\n\tpublic static var changed(default, null):Signal0 = new Signal0();\r\n\r\n\tpublic static function update() {\r\n\t\tAjax.request(\r\n\t\t\tHTTPMethod.GET,\r\n\t\t\t'/api/v1/logs'\r\n\t\t).then(function(res:Response) {\r\n\t\t\tvar data = haxe.Json.parse(res.response);\r\n\t\t\tfiles = data;\r\n\t\t\tchanged.dispatch();\r\n\t\t}).catchError(function(err:Dynamic) {\r\n\t\t\tApp.console.log(err);\r\n\t\t});\r\n\t}\r\n}","package stores;\r\n\r\nimport msignal.Signal;\r\n\r\nimport Ajax;\r\nimport Ajax.HTTPMethod;\r\nimport Ajax.Response;\r\n\r\nclass LogStore {\r\n\tprivate function new(){}\r\n\tpublic static var file(default, null):String;\r\n\tpublic static var entries(default, null):Array<LogEntry>;\r\n\tpublic static var changed(default, null):Signal0 = new Signal0();\r\n\r\n\tpublic static function update(filename:String) {\r\n\t\tAjax.request(\r\n\t\t\tHTTPMethod.GET,\r\n\t\t\t'/api/v1/log/' + filename\r\n\t\t).then(function(res:Response) {\r\n\t\t\tvar data = haxe.Json.parse(res.response);\r\n\t\t\tfile = data.f;\r\n\t\t\tentries = data.d;\r\n\t\t\tchanged.dispatch();\r\n\t\t}).catchError(function(err:Dynamic) {\r\n\t\t\tApp.console.log(err);\r\n\t\t});\r\n\t}\r\n}","package views;\r\n\r\nimport api.react.ReactComponent;\r\nimport api.react.ReactMacro.jsx;\r\nimport js.html.Element;\r\nimport js.html.Event;\r\n\r\ntypedef LogFilesState = {\r\n\tvar files:Array<String>;\r\n};\r\n\r\ntypedef LogFilenameProps = {\r\n\tvar name:String;\r\n};\r\n\r\nclass LogFiles extends ReactComponentOfState<LogFilesState> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t\tstate = {\r\n\t\t\tfiles: new Array<String>()\r\n\t\t};\r\n\t}\r\n\r\n\tprivate function update() {\r\n\t\tsetState({\r\n\t\t\tfiles: stores.ListStore.files\r\n\t\t});\r\n\t}\r\n\r\n\toverride public function componentDidMount() {\r\n\t\tstores.ListStore.changed.add(update);\r\n\t}\r\n\r\n\toverride public function componentWillUnmount() {\r\n\t\tstores.ListStore.changed.remove(update);\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\treturn jsx('\r\n\t\t\t<ul>${createChildren()}</ul>\r\n\t\t');\r\n\t}\r\n\r\n\tprivate function createChildren() {\r\n\t\treturn [for(file in state.files) jsx('<LogFilename key={file} name={file}/>')];\r\n\t}\r\n}\r\n\r\nclass LogFilename extends ReactComponentOfProps<LogFilenameProps> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\treturn jsx('<li onClick=${handleClick}><a href=\"#\">{this.props.name}</a></li>');\r\n\t}\r\n\r\n\tfunction handleClick() {\r\n\t\tstores.LogStore.update(this.props.name);\r\n\t}\r\n}","package views;\r\n\r\nimport api.react.ReactComponent;\r\nimport api.react.ReactMacro.jsx;\r\nimport js.html.Element;\r\nimport js.html.Event;\r\n\r\ntypedef LogInspectorState = {\r\n\tvar file:String;\r\n\tvar entries:Array<LogEntry>;\r\n};\r\n\r\ntypedef LogHeaderProps = {\r\n\tvar file:String;\r\n};\r\n\r\ntypedef LogEntriesProps = {\r\n\tvar entries:Array<LogEntry>;\r\n};\r\n\r\ntypedef LogEntryItemProps = {\r\n\tvar item:LogEntry;\r\n};\r\n\r\nclass LogInspector extends ReactComponentOfState<LogInspectorState> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t\tstate = {\r\n\t\t\tfile: '',\r\n\t\t\tentries: []\r\n\t\t};\r\n\t}\r\n\r\n\tprivate function update() {\r\n\t\tsetState({\r\n\t\t\tfile: stores.LogStore.file,\r\n\t\t\tentries: stores.LogStore.entries\r\n\t\t});\r\n\t}\r\n\r\n\toverride public function componentDidMount() {\r\n\t\tstores.LogStore.changed.add(update);\r\n\t}\r\n\r\n\toverride public function componentWillUnmount() {\r\n\t\tstores.LogStore.changed.remove(update);\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\treturn jsx('\r\n\t\t\t<section>\r\n\t\t\t\t<$LogHeader file=${state.file}/>\r\n\t\t\t\t<$LogEntries entries=${state.entries}/>\r\n\t\t\t</section>\r\n\t\t');\r\n\t}\r\n}\r\n\r\nclass LogHeader extends ReactComponentOfProps<LogHeaderProps> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\treturn jsx('<header><h1>${props.file}</h1></header>');\r\n\t}\r\n}\r\n\r\nclass LogEntries extends ReactComponentOfProps<LogEntriesProps> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\treturn jsx('\r\n\t\t\t<ul>\r\n\t\t\t\t${createChildren()}\r\n\t\t\t</ul>\r\n\t\t');\r\n\t}\r\n\r\n\tprivate function createChildren() {\r\n\t\treturn [for(entry in props.entries) jsx('<LogEntryItem key={entry.date} item={entry}/>')];\r\n\t}\r\n}\r\n\r\nclass LogEntryItem extends ReactComponentOfProps<LogEntryItemProps> {\r\n\tpublic function new() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\toverride public function render() {\r\n\t\tvar entry:LogEntry = props.item;\r\n\t\tvar data:String = entry.data != null ? haxe.Json.stringify(entry.data) : '';\r\n\t\treturn jsx('\r\n\t\t\t<li>\r\n\t\t\t\t<span className=\"date\">${entry.date}</span>\r\n\t\t\t\t<span className=\"severity\">\r\n\t\t\t\t\t<span className=\"${entry.severity}\"/>\r\n\t\t\t\t</span>\r\n\t\t\t\t<span className=\"message\">${entry.message}</span>\r\n\t\t\t\t<span className=\"data\">${data}</span>\r\n\t\t\t</li>\r\n\t\t');\r\n\t}\r\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n"],
"names":[],
"mappings":"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"
}